<!DOCTYPE html>
<html lang="ja">
<head>
    <script>
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.has('nosave')) {
          console.log('Google Analytics is disabled via ?nosave parameter.');
      } else {
          var script = document.createElement('script');
          script.async = true;
          script.src = "https://www.googletagmanager.com/gtag/js?id=G-WLRD9NY9NX";
          document.head.appendChild(script);

          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-WLRD9NY9NX');
      }
    </script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Professional Shogi Board</title>
    <style>
        :root {
            --board-bg: #dab982;
            --cell-border: #4e342e;
            --sente-color: #1a1a1a;
            --gote-color: #353535;
            --nari-sente-color: #d32f2f;
            --nari-gote-color: #bb1919;
            --highlight-bg: rgba(211, 84, 0, 0.3);
            --last-move-bg: rgba(255, 255, 0, 0.4);
            --move-hint: rgba(0, 0, 0, 0.15);
            --text-main: #3e2723;
            --ui-bg: #e0d7d2;
            --sente-accent: #d35400;
            --btn-bg: #5d4037;
            
            --sente-rotate: 0deg;
            --gote-rotate: 180deg;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }

        body { 
            font-family: "Hiragino Sans", "Hiragino Kaku Gothic ProN", sans-serif; 
            background: #1a1a1a; color: var(--text-main); display: flex; flex-direction: column;
            align-items: center; margin: 0; padding: 10px; user-select: none;
            overscroll-behavior-y: none;
        }

        .lang-control { width: 100%; max-width: 1400px; display: flex; justify-content: flex-end; margin-bottom: 5px; }
        .lang-btn { background: #444; color: #fff; border: none; padding: 5px 15px; border-radius: 20px; cursor: pointer; font-size: 0.8rem; }

        .main-container { display: flex; gap: 20px; width: 100%; max-width: 1400px; }

        @media (max-width: 1000px) {
            .main-container { flex-direction: column; align-items: center; }
            .side-panel { width: 100% !important; max-width: 600px; }
            #board { grid-template-columns: repeat(9, 10.5vw) !important; grid-template-rows: repeat(9, 11.5vw) !important; }
            .piece { font-size: 7.5vw !important; }
            .komadai-row { width: 95vw !important; height: 85px !important; }
            .komadai { width: calc(50% - 4px) !important; }
        }

        .board-area { 
            display: flex; flex-direction: column; gap: 5px; align-items: center; flex: 1;
            touch-action: manipulation; 
        }
        
        .board-reversable-wrapper {
            display: flex; flex-direction: column; gap: 8px; align-items: center;
            width: 100%;
        }
        .board-reversable-wrapper.reversed { flex-direction: column-reverse; }

        .komadai-row {
            display: flex; gap: 8px; width: 540px; justify-content: space-between;
            height: 85px; 
        }
        .reversed .komadai-row { flex-direction: row-reverse; }

        .komadai { 
            flex: 1; height: 85px;
            background: #a1887f; padding: 2px 4px; border-radius: 8px; 
            display: flex; align-content: flex-start; align-items: center; flex-wrap: wrap;
            gap: 2px; border: 2px solid transparent; transition: all 0.3s;
            overflow: hidden; 
            touch-action: manipulation;
        }
        .komadai.active-sente { border-color: var(--sente-accent); box-shadow: 0 0 12px var(--sente-accent); background: #b09a92; }
        .komadai.active-gote { border-color: #eee; box-shadow: 0 0 12px #eee; background: #b09a92; }

        .player-badge {
            background: rgba(0,0,0,0.25); color: #fff; padding: 2px 0;
            border-radius: 4px; font-size: 0.6rem; font-weight: bold;
            width: 100%; text-align: center; margin-bottom: 2px;
        }
        .active-sente .player-badge { background: var(--sente-accent); }
        .active-gote .player-badge { background: #eee; color: #333; }
        .reversed .player-badge { transform: rotate(180deg); }

        .board-wrapper { position: relative; background: #4e342e; padding: 10px; border-radius: 4px; margin: 0; }
        #board { 
            display: grid; grid-template-columns: repeat(9, 60px); grid-template-rows: repeat(9, 66px); 
            background: var(--board-bg); border: 1px solid var(--cell-border);
            touch-action: manipulation;
        }
        .cell { border: 0.5px solid var(--cell-border); display: flex; justify-content: center; align-items: center; position: relative; cursor: pointer; }
        .cell.selected { background: var(--highlight-bg); }
        .cell.last-move { background: var(--last-move-bg); }
        .cell.can-move::after { content: ""; width: 16px; height: 16px; background: var(--move-hint); border-radius: 50%; position: absolute; z-index: 1; }

        .piece {
            font-size: 44px; font-weight: bold; pointer-events: none; color: var(--sente-color);
            position: relative; z-index: 2; transform: rotate(var(--sente-rotate)); transition: transform 0.3s;
        }
        .piece.gote { color: var(--gote-color); transform: rotate(var(--gote-rotate)); }
        .piece.nari { color: var(--nari-sente-color); }
        .piece.nari.gote { color: var(--nari-gote-color); }

        .piece-moti { font-size: 20px !important; }

        .side-panel { width: 360px; display: flex; flex-direction: column; gap: 15px; touch-action: auto; }
        .card { background: var(--ui-bg); padding: 15px; border-radius: 12px; border: 1px solid #a1887f; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .card-title { font-size: 0.9rem; font-weight: bold; margin-bottom: 8px; border-left: 4px solid var(--btn-bg); padding-left: 8px; }

        .action-btn { 
            width: 100%; padding: 10px; font-weight: bold; border: none; border-radius: 6px; 
            color: #fff; background: var(--btn-bg); cursor: pointer; margin-top: 4px; font-size: 0.9rem; 
        }
        .action-btn:active { opacity: 0.7; transform: scale(0.98); }
        .action-btn.active { background: var(--sente-accent); }

        input[type="text"] { width: 100%; padding: 10px; border-radius: 6px; border: 2px solid #a1887f; margin-bottom: 5px; outline: none; }
        .kifu-select { width: 100%; padding: 8px; border-radius: 6px; height: 120px; font-size: 0.9rem; margin-bottom: 5px; }
        .history-box { height: 180px; overflow-y: scroll; background: #efebe9; border: 1px solid #a1887f; border-radius: 6px; -webkit-overflow-scrolling: touch; }
        .history-item { padding: 8px; border-bottom: 1px solid #d7ccc8; font-size: 0.85rem; cursor: pointer; }
        .current-move { background: #d7ccc8; border-left: 5px solid var(--sente-accent); font-weight: bold; }
        
        .moti-item { display: flex; align-items: center; cursor: pointer; padding: 1px; border-radius: 4px; position: relative; flex-shrink: 0; }
        .moti-item.selected { background: var(--highlight-bg); }
        .moti-count { font-size: 10px; font-weight: bold; margin-left: 1px; color: #fff; text-shadow: 1px 1px 2px #000; }

        #toast-container { position: fixed; bottom: 20px; left: 20px; z-index: 9999; display: flex; flex-direction: column; gap: 10px; pointer-events: none; }
        .toast { background: rgba(40, 40, 40, 0.9); color: #fff; padding: 12px 20px; border-radius: 8px; font-size: 0.9rem; box-shadow: 0 4px 10px rgba(0,0,0,0.3); animation: toastIn 0.3s ease-out forwards; border-left: 5px solid var(--sente-accent); }
        @keyframes toastIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes toastOut { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(20px); } }
    </style>
</head>
<body>

<div class="lang-control">
    <button class="lang-btn" onclick="toggleLang()" id="langSwitcher">EN / 日本語</button>
</div>

<div class="main-container">
    <div class="board-area">
        <div class="board-reversable-wrapper" id="boardReversableWrapper">
            <div class="board-wrapper">
                <div id="board"></div>
                <div id="promoteSelector" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #fff; padding: 20px; border-radius: 12px; display: none; z-index: 100; gap: 40px; border: 3px solid var(--btn-bg);">
                    <div onclick="processPromotion(true)" style="text-align:center; cursor:pointer;"><div class="piece sente nari" id="promoYesPiece"></div><div data-t="promote">成る</div></div>
                    <div onclick="processPromotion(false)" style="text-align:center; cursor:pointer;"><div class="piece sente" id="promoNoPiece"></div><div data-t="dontPromote">成らず</div></div>
                </div>
            </div>

            <div class="komadai-row">
                <div class="komadai gote" id="goteKomadaiContainer"></div>
                <div class="komadai sente" id="senteKomadaiContainer"></div>
            </div>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; width: 100%; max-width: 540px; margin-top: 5px;">
            <button class="action-btn" onclick="jumpTo(0)">|&lt;</button>
            <button class="action-btn" onclick="prevMove()">&lt;</button>
            <button class="action-btn" onclick="nextMove()">&gt;</button>
            <button class="action-btn" onclick="jumpTo(history.length - 1)">&gt;|</button>
        </div>
    </div>

    <div class="side-panel">
        <div class="card">
            <span class="card-title" data-t="saveTitle">棋譜の保存</span>
            <input type="text" id="kifuName" data-p="placeholderName" placeholder="棋譜名を入力...">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                <button class="action-btn" style="background:var(--sente-accent);" onclick="saveKifu()" data-t="btnSave">新規保存</button>
                <button class="action-btn" style="background:#8d6e63;" onclick="renameKifu()" data-t="btnRename">名前変更</button>
            </div>
        </div>
        <div class="card">
            <span class="card-title" data-t="listTitle">保存リスト</span>
            <select id="kifuList" size="5" class="kifu-select" multiple></select>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                <button class="action-btn" style="background:#2c3e50;" onclick="loadKifu()" data-t="btnLoad">読込</button>
                <button class="action-btn" style="background:#c0392b;" onclick="deleteKifu()" data-t="btnDelete">選択削除</button>
            </div>
        </div>
        <div class="card">
            <span class="card-title" data-t="backupTitle">入出力</span>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                <button class="action-btn" style="background:#27ae60;" onclick="exportKIF()" data-t="btnExport">KIF出力</button>
                <button class="action-btn" style="background:#2980b9;" onclick="document.getElementById('kifIn').click()" data-t="btnImportKif">KIF読込</button>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 5px;">
                <button class="action-btn" style="background:#7f8c8d;" onclick="exportAllJSON()" data-t="allDL">まとめてDL</button>
                <button class="action-btn" style="background:#8e44ad;" onclick="document.getElementById('jsonIn').click()" data-t="allUL">まとめてUL</button>
            </div>
            <input type="file" id="kifIn" style="display:none" accept=".kif" onchange="importKIF(event)">
            <input type="file" id="jsonIn" style="display:none" accept=".json" onchange="importAllJSON(event)">
        </div>
        <div class="card">
            <span class="card-title" data-t="historyTitle">指し手履歴</span>
            <div id="history" class="history-box"></div>
            <button class="action-btn" style="margin-top:8px;background:#1976d2;" onclick="copyKIF()">KIF形式コピー</button>
        </div>
        <div class="card">
            <span class="card-title" data-t="settingsTitle">設定</span>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                <button class="action-btn" onclick="toggleBoardRotation()" id="btnRotate" data-t="btnRotate">盤面反転</button>
                <button class="action-btn" onclick="toggleSound()" id="btnSound" data-t="btnSound">効果音: OFF</button>
            </div>
        </div>
    </div>
</div>

<div id="toast-container"></div>

<script>
    // ▼▼▼ ここに読み込ませたいKIFの中身を直接貼り付けてください ▼▼▼
    const PRELOAD_KIFS = {
        "四間飛車": `
#KIF version=2.0 encoding=UTF-8
開始日時：2024/01/01
棋戦：四間飛車定跡
手合割：平手
手数----指手---------消費時間--
   1 ７六歩(77)   ( 0:12/00:00:12)
   2 ３四歩(33)   ( 0:02/00:00:02)
   3 ６六歩(67)   ( 0:02/00:00:14)
   4 ８四歩(83)   ( 0:03/00:00:05)
   5 ６八飛(28)   ( 0:02/00:00:16)
   6 ８五歩(84)   ( 0:02/00:00:07)
   7 ７七角(88)   ( 0:01/00:00:17)
   8 ６二銀(71)   ( 0:02/00:00:09)
   9 ７八銀(79)   ( 0:03/00:00:20)
  10 ４二玉(51)   ( 0:02/00:00:11)
  11 ４八玉(59)   ( 0:01/00:00:21)
  12 ３二玉(42)   ( 0:01/00:00:12)
  13 ３八玉(48)   ( 0:01/00:00:22)
  14 ５四歩(53)   ( 0:02/00:00:14)
  15 ２八玉(38)   ( 0:02/00:00:24)
  16 ５三銀(62)   ( 0:02/00:00:16)
  17 ３八銀(39)   ( 0:03/00:00:27)
  18 ５二金(61)   ( 0:07/00:00:23)
  19 １六歩(17)   ( 0:03/00:00:30)
  20 １四歩(13)   ( 0:01/00:00:24)
  21 ５八金(69)   ( 0:01/00:00:31)
  22 ７四歩(73)   ( 0:07/00:00:31)
  23 ６七銀(78)   ( 0:02/00:00:33)
  24 ６四銀(53)   ( 0:29/00:01:00)
  25 ７八飛(68)   ( 0:03/00:00:36)
  26 ７五歩(74)   ( 0:03/00:01:03)
`,
        "中飛車": `
#KIF version=2.0 encoding=UTF-8
開始日時：2024/01/01
棋戦：中飛車定跡
手合割：平手
手数----指手---------消費時間--
   1 ５六歩(57)   ( 0:01/00:00:01)
   2 ３四歩(33)   ( 0:01/00:00:01)
   3 ５八飛(28)   ( 0:01/00:00:02)
   4 ８四歩(83)   ( 0:09/00:00:10)
   5 ７六歩(77)   ( 0:02/00:00:04)
   6 ８五歩(84)   ( 0:03/00:00:13)
   7 ５五歩(56)   ( 0:01/00:00:05)
   8 ４二玉(51)   ( 0:02/00:00:15)
   9 ７七角(88)   ( 0:01/00:00:06)
  10 ３二玉(42)   ( 0:02/00:00:17)
  11 ４八玉(59)   ( 0:01/00:00:07)
  12 ６二銀(71)   ( 0:05/00:00:22)
  13 ６八銀(79)   ( 0:01/00:00:08)
  14 ７四歩(73)   ( 0:02/00:00:24)
  15 １六歩(17)   ( 0:01/00:00:09)
  16 １四歩(13)   ( 0:02/00:00:26)
  17 ３八玉(48)   ( 0:02/00:00:11)
  18 ４二銀(31)   ( 0:03/00:00:29)
  19 ５七銀(68)   ( 0:01/00:00:12)
  20 ７三銀(62)   ( 0:01/00:00:30)
  21 ６六銀(57)   ( 0:06/00:00:18)
  22 ５二金(61)   ( 0:01/00:00:31)
  23 ２八玉(38)   ( 0:04/00:00:22)
  24 ６四銀(73)   ( 0:11/00:00:42)
`
    };
    // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

    const i18n = {
        ja: {
            promote: "成る", dontPromote: "成らず", senteBadge: "▲ 先手", goteBadge: "△ 後手",
            saveTitle: "棋譜の保存", placeholderName: "棋譜名を入力...", btnSave: "新規保存", btnRename: "名前変更",
            listTitle: "保存リスト", btnLoad: "読込", btnDelete: "選択削除",
            backupTitle: "入出力", btnExport: "KIF出力", btnImportKif: "KIF読込", allDL: "まとめてDL", allUL: "まとめてUL",
            historyTitle: "指し手履歴", startPos: "開始局面", msgSaved: "保存しました", msgNoData: "データがありません",
            msgRestoreConfirm: "既存データに上書き統合しますか？", msgDone: "完了しました", msgKifError: "KIF解析エラー",
            msgSelectOne: "読込には1つだけ選択してください", msgRenamePrompt: "新しい名前を入力してください",
            msgConfirmDel: "選択した棋譜を削除しますか？", msgUchifuzume: "打ち歩詰めは反則です",
            settingsTitle: "設定", btnRotate: "盤面反転", btnSound: "効果音: ",
            copySuccess: "KIF形式でコピーしました", copyFail: "コピーに失敗しました"
        },
        en: {
            promote: "Promote", dontPromote: "No Promote", senteBadge: "Sente (Black)", goteBadge: "Gote (White)",
            saveTitle: "Save Kifu", placeholderName: "Enter name...", btnSave: "Save New", btnRename: "Rename",
            listTitle: "Kifu List", btnLoad: "Load", btnDelete: "Delete Selected",
            backupTitle: "I/O", btnExport: "Export KIF", btnImportKif: "Import KIF", allDL: "Bulk DL", allUL: "Bulk UL",
            historyTitle: "History", startPos: "Start", msgSaved: "Saved", msgNoData: "No data",
            msgRestoreConfirm: "Merge with existing data?", msgDone: "Done", msgKifError: "KIF Error",
            msgSelectOne: "Please select only one to load", msgRenamePrompt: "Enter new name",
            msgConfirmDel: "Delete selected items?", msgUchifuzume: "Pawn Drop Mate is illegal",
            settingsTitle: "Settings", btnRotate: "Rotate Board", btnSound: "Sound: ",
            copySuccess: "Copied to clipboard", copyFail: "Copy failed"
        }
    };

    let currentLang = localStorage.getItem('SHOGI_LANG') || 'ja';
    let isRotated = false; let isSoundOn = false; let audioCtx = null;
    let history = []; let currentIndex = 0; let selected = null; let pendingMove = null;

    const kanjiMap = {'p':'歩','r':'飛','b':'角','g':'金','s':'銀','n':'桂','l':'香','k':'玉','+p':'と','+r':'竜','+b':'馬','+s':'全','+n':'圭','+l':'杏'};
    const kifPieceMap = {'歩':'p','飛':'r','角':'b','金':'g','銀':'s','桂':'n','香':'l','玉':'k','王':'k','と':'+p','竜':'+r','龍':'+r','馬':'+b','成銀':'+s','成桂':'+n','成香':'+l','全':'+s','圭':'+n','杏':'+l'};
    const pieceToKif = {'p':'歩','r':'飛','b':'角','g':'金','s':'銀','n':'桂','l':'香','k':'玉','+p':'と','+r':'竜','+b':'馬','+s':'成銀','+n':'成桂','+l':'成香'};
    const STORAGE_KEY = 'SHOGI_APP_DATA_V5';

    const initBoard = [
        ['L','N','S','G','K','G','S','N','L'], ['','R','','','','','','B',''], ['P','P','P','P','P','P','P','P','P'],
        ['','','','','','','','',''],['','','','','','','','',''],['','','','','','','','',''],
        ['p','p','p','p','p','p','p','p','p'], ['','b','','','','','','r',''], ['l','n','s','g','k','g','s','n','l']
    ];

    function updateUIStrings() {
        document.querySelectorAll('[data-t]').forEach(el => { if(i18n[currentLang][el.dataset.t]) el.innerText = i18n[currentLang][el.dataset.t]; });
        document.querySelectorAll('[data-p]').forEach(el => { el.placeholder = i18n[currentLang][el.dataset.p]; });
        document.getElementById('langSwitcher').innerText = currentLang === 'ja' ? "EN / 日本語" : "日本語 / EN";
        document.getElementById('btnSound').innerText = i18n[currentLang].btnSound + (isSoundOn ? "ON" : "OFF");
    }
    function toggleLang() { currentLang = currentLang === 'ja' ? 'en' : 'ja'; localStorage.setItem('SHOGI_LANG', currentLang); updateUIStrings(); render(); }
    function showToast(msg) {
        const container = document.getElementById('toast-container');
        const el = document.createElement('div'); el.className = 'toast'; el.innerText = msg;
        container.appendChild(el);
        setTimeout(() => { el.style.animation = 'toastOut 0.3s ease-in forwards'; el.addEventListener('animationend', () => el.remove()); }, 3000);
    }
    function toggleBoardRotation() {
        isRotated = !isRotated;
        const root = document.documentElement;
        const wrapper = document.getElementById('boardReversableWrapper');
        if (isRotated) {
            root.style.setProperty('--sente-rotate', '180deg'); root.style.setProperty('--gote-rotate', '0deg');
            wrapper.classList.add('reversed'); document.getElementById('btnRotate').classList.add('active');
        } else {
            root.style.setProperty('--sente-rotate', '0deg'); root.style.setProperty('--gote-rotate', '180deg');
            wrapper.classList.remove('reversed'); document.getElementById('btnRotate').classList.remove('active');
        }
        render();
    }
    function toggleSound() {
        isSoundOn = !isSoundOn;
        document.getElementById('btnSound').innerText = i18n[currentLang].btnSound + (isSoundOn ? "ON" : "OFF");
        if (isSoundOn) { 
            document.getElementById('btnSound').classList.add('active');
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } else document.getElementById('btnSound').classList.remove('active');
    }
    function playMoveSound() {
        if (!isSoundOn || !audioCtx) return;
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const t = audioCtx.currentTime;
        const masterGain = audioCtx.createGain();
        const compressor = audioCtx.createDynamicsCompressor();
        compressor.connect(audioCtx.destination); masterGain.connect(compressor);
        const osc = audioCtx.createOscillator(); const g = audioCtx.createGain();
        osc.type = 'triangle'; osc.frequency.setValueAtTime(600, t); osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);
        g.gain.setValueAtTime(0.4, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        osc.connect(g); g.connect(masterGain); osc.start(t); osc.stop(t + 0.1);
    }

    function getCleanHistory() { return [{ board: JSON.parse(JSON.stringify(initBoard)), senteMoti: [], goteMoti: [], moveText: i18n[currentLang].startPos, turn: 0, lastPos: null, kifMove: "" }]; }

    function render() {
        const data = history[currentIndex];
        const boardEl = document.getElementById('board'); boardEl.innerHTML = '';
        document.getElementById('senteKomadaiContainer').className = "komadai sente" + (data.turn===0 ? " active-sente" : "");
        document.getElementById('goteKomadaiContainer').className = "komadai gote" + (data.turn===1 ? " active-gote" : "");
        
        for (let rowIdx = 0; rowIdx < 9; rowIdx++) {
            for (let colIdx = 0; colIdx < 9; colIdx++) {
                const r = isRotated ? 8 - rowIdx : rowIdx; const c = isRotated ? 8 - colIdx : colIdx;
                const cell = document.createElement('div'); cell.className = 'cell';
                if (selected?.type === 'board' && selected.r === r && selected.c === c) cell.classList.add('selected');
                if (data.lastPos && data.lastPos.r === r && data.lastPos.c === c) cell.classList.add('last-move');
                if (selected) {
                    if (selected.type === 'board') {
                        if (isValidMove(selected.r, selected.c, r, c, data.board[selected.r][selected.c], data.board)) {
                            const temp = JSON.parse(JSON.stringify(data.board)); temp[r][c] = temp[selected.r][selected.c]; temp[selected.r][selected.c] = '';
                            if (!isKingInCheck(temp, data.turn)) cell.classList.add('can-move');
                        }
                    } else if (selected.type === 'moti') {
                        if (data.board[r][c] === '' && canExistAt(selected.piece, r, data.turn===0)) {
                            if (selected.piece !== 'p' || !isNifu(c, data.turn===0, data.board)) {
                                const temp = JSON.parse(JSON.stringify(data.board)); temp[r][c] = data.turn === 0 ? selected.piece : selected.piece.toUpperCase();
                                if (!isKingInCheck(temp, data.turn)) cell.classList.add('can-move');
                            }
                        }
                    }
                }
                const p = data.board[r][c];
                if (p) {
                    const span = document.createElement('span');
                    span.className = 'piece ' + (p === p.toUpperCase() ? 'gote ' : 'sente ') + (p.includes('+') ? 'nari' : '');
                    span.innerText = kanjiMap[p.toLowerCase()]; cell.appendChild(span);
                }
                cell.onclick = (e) => { handleCellClick(r, c); }; boardEl.appendChild(cell);
            }
        }
        renderMoti('senteKomadaiContainer', data.senteMoti, 0);
        renderMoti('goteKomadaiContainer', data.goteMoti, 1);
        updateHistoryUI();
    }

    function isKingInCheck(board, turn) {
        let kr = -1, kc = -1; 
        const targetKing = turn === 0 ? 'k' : 'K';
        for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) if (board[r][c] === targetKing) { kr = r; kc = c; }
        if (kr === -1) return false;

        for (let r = 0; r < 9; r++) {
            for (let c = 0; c < 9; c++) {
                const p = board[r][c];
                if (!p) continue;
                const isSentePiece = p === p.toLowerCase();
                if ((turn === 0 && !isSentePiece) || (turn === 1 && isSentePiece)) {
                    if (isValidMove(r, c, kr, kc, p, board, true)) return true;
                }
            }
        }
        return false;
    }

    function isNifu(col, isSente, board) {
        for (let r = 0; r < 9; r++) { const p = board[r][col]; if (isSente && p === 'p') return true; if (!isSente && p === 'P') return true; }
        return false;
    }

    function hasLegalMove(board, turn, moti) {
        for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) {
            const p = board[r][c]; if (!p) continue;
            if ((turn === 0 && p === p.toLowerCase()) || (turn === 1 && p === p.toUpperCase())) {
                for (let tr = 0; tr < 9; tr++) for (let tc = 0; tc < 9; tc++) {
                    if (isValidMove(r, c, tr, tc, p, board)) {
                        const temp = JSON.parse(JSON.stringify(board)); temp[tr][tc] = temp[r][c]; temp[r][c] = '';
                        if (!isKingInCheck(temp, turn)) return true;
                    }
                }
            }
        }
        for (let p of [...new Set(moti)]) {
            for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) {
                if (board[r][c] === '' && canExistAt(p, r, turn===0) && (p !== 'p' || !isNifu(c, turn===0, board))) {
                    const temp = JSON.parse(JSON.stringify(board)); temp[r][c] = turn === 0 ? p : p.toUpperCase();
                    if (!isKingInCheck(temp, turn)) return true;
                }
            }
        }
        return false;
    }

    function renderMoti(id, pieces, owner) {
        const el = document.getElementById(id); el.innerHTML = '';
        const badge = document.createElement('div'); badge.className = 'player-badge';
        badge.innerText = owner === 0 ? i18n[currentLang].senteBadge : i18n[currentLang].goteBadge;
        el.appendChild(badge);
        const counts = {}; (pieces||[]).forEach(p => counts[p] = (counts[p] || 0) + 1);
        ['r','b','g','s','n','l','p'].forEach(type => {
            if (counts[type]) {
                const item = document.createElement('div');
                item.className = 'moti-item' + (selected?.type === 'moti' && selected.piece === type && selected.owner === owner ? ' selected' : '');
                const span = document.createElement('span'); span.className = 'piece piece-moti' + (owner===1?' gote':'');
                span.innerText = kanjiMap[type]; item.appendChild(span);
                if(counts[type]>1){ const b=document.createElement('span'); b.className='moti-count'; b.innerText=counts[type]; item.appendChild(b); }
                item.onclick = (e) => { if(history[currentIndex].turn === owner) { selected = {type:'moti', piece:type, owner:owner}; render(); } };
                el.appendChild(item);
            }
        });
    }

    function handleCellClick(r, c) {
        const d = history[currentIndex];
        if (selected) {
            if (selected.type === 'board') {
                if (isValidMove(selected.r, selected.c, r, c, d.board[selected.r][selected.c], d.board)) {
                    const temp = JSON.parse(JSON.stringify(d.board)); temp[r][c] = temp[selected.r][selected.c]; temp[selected.r][selected.c] = '';
                    if (!isKingInCheck(temp, d.turn)) checkPromotion(selected.r, selected.c, r, c, d.board[selected.r][selected.c]);
                    selected = null;
                } else {
                    const p = d.board[r][c]; if (p && ((d.turn===0 && p===p.toLowerCase()) || (d.turn===1 && p===p.toUpperCase()))) selected = {type:'board', r:r, c:c}; else selected = null;
                }
            } else if (selected.type === 'moti') {
                const isSente = d.turn === 0;
                if (d.board[r][c] === '' && canExistAt(selected.piece, r, isSente) && (selected.piece !== 'p' || !isNifu(c, isSente, d.board))) {
                    const temp = JSON.parse(JSON.stringify(d.board)); temp[r][c] = isSente ? selected.piece : selected.piece.toUpperCase();
                    if (!isKingInCheck(temp, d.turn)) {
                        if (selected.piece === 'p' && isKingInCheck(temp, 1-d.turn) && !hasLegalMove(temp, 1-d.turn, (1-d.turn===0?d.senteMoti:d.goteMoti))) showToast(i18n[currentLang].msgUchifuzume);
                        else executeMove(null, null, r, c, selected.piece, false, true);
                    }
                    selected = null;
                } else selected = null;
            }
        } else {
            const p = d.board[r][c]; if (p && ((d.turn===0 && p===p.toLowerCase()) || (d.turn===1 && p===p.toUpperCase()))) selected = {type:'board', r:r, c:c};
        }
        render();
    }

    function canExistAt(t, row, isS) { if (isS) { if (t==='p'||t==='l') return row>0; if (t==='n') return row>1; } else { if (t==='p'||t==='l') return row<8; if (t==='n') return row<7; } return true; }

    function isValidMove(fr, fc, tr, tc, p, b, isCheckingMode = false) {
        const isS = p === p.toLowerCase(); const dr = tr-fr, dc = tc-fc, adr = Math.abs(dr), adc = Math.abs(dc);
        if (!isCheckingMode && b[tr][tc] !== '' && (b[tr][tc] === b[tr][tc].toLowerCase()) === isS) return false;
        
        const t = p.toLowerCase();
        const checkPath = () => { 
            const sr = dr === 0 ? 0 : dr / adr;
            const sc = dc === 0 ? 0 : dc / adc;
            let cr = fr + sr; let cc = fc + sc;
            while (cr !== tr || cc !== tc) {
                if (b[cr][cc] !== '') return false;
                cr += sr; cc += sc;
            }
            return true;
        };

        switch (t) {
            case 'p': return dc===0 && (isS ? dr===-1 : dr===1);
            case 'l': return dc===0 && (isS ? dr<0 : dr>0) && checkPath();
            case 'n': return adc===1 && (isS ? dr===-2 : dr===2);
            case 's': return (adr===1 && adc===1) || (adc===0 && (isS ? dr===-1 : dr===1));
            case 'g': case '+p': case '+l': case '+n': case '+s': return (adr<=1 && adc<=1) && !(isS ? (dr===1 && adc===1) : (dr===-1 && adc===1));
            case 'k': return adr<=1 && adc<=1;
            case 'r': return (dr===0 || dc===0) && checkPath();
            case '+r': return (dr===0 || dc===0) ? checkPath() : (adr===1 && adc===1);
            case 'b': return adr===adc && checkPath();
            case '+b': return (adr===adc) ? checkPath() : (adr<=1 && adc<=1);
        } return false;
    }

    function checkPromotion(fr,fc,tr,tc,p) {
        const isS = p===p.toLowerCase(); const t = p.toLowerCase();
        const can = ['p','l','n','s','b','r'].includes(t) && !p.includes('+') && (isS ? tr<=2||fr<=2 : tr>=6||fr>=6);
        if (!canExistAt(t, tr, isS)) executeMove(fr,fc,tr,tc,t,true);
        else if (can) { pendingMove = {fr,fc,tr,tc,p:t}; document.getElementById('promoYesPiece').innerText = kanjiMap['+'+t]; document.getElementById('promoNoPiece').innerText = kanjiMap[t]; document.getElementById('promoteSelector').style.display='flex'; }
        else executeMove(fr,fc,tr,tc,t,false);
    }
    function processPromotion(n) { document.getElementById('promoteSelector').style.display='none'; executeMove(pendingMove.fr, pendingMove.fc, pendingMove.tr, pendingMove.tc, pendingMove.p, n); }

    function getKifuMoveText(fr, fc, tr, tc, pCode, isPromote, isDrop, board, turn, lastPos) {
        const isSente = turn === 0; const zenNum = ["１","２","３","４","５","６","７","８","９"]; const kanNum = ["一","二","三","四","五","六","七","八","九"];
        let txt = (isSente ? "▲" : "△") + (lastPos && lastPos.r === tr && lastPos.c === tc ? "同　" : zenNum[8-tc] + kanNum[tr]) + pieceToKif[pCode];
        if (isPromote) txt += "成"; else if (['p','l','n','s','b','r'].includes(pCode) && !pCode.includes('+') && !isDrop && (isSente ? tr<=2||fr<=2 : tr>=6||fr>=6)) txt += "不成";
        return txt + (isDrop ? "打" : `(${9-fc}${fr+1})`);
    }

    function executeMove(fr, fc, tr, tc, p, isPromote, isDrop = false, silent = false) {
        const d = history[currentIndex]; const nb = JSON.parse(JSON.stringify(d.board));
        const sm = [...d.senteMoti], gm = [...d.goteMoti], isSente = d.turn === 0;
        const moveText = getKifuMoveText(fr, fc, tr, tc, p, isPromote, isDrop, d.board, d.turn, d.lastPos);
        if (isDrop) { nb[tr][tc] = isSente ? p : p.toUpperCase(); (isSente ? sm : gm).splice((isSente ? sm : gm).indexOf(p), 1); }
        else { if (nb[tr][tc]) (isSente ? sm : gm).push(nb[tr][tc].replace('+', '').toLowerCase()); nb[tr][tc] = isSente ? (isPromote ? "+" + p : p) : (isPromote ? "+" + p : p).toUpperCase(); nb[fr][fc] = ''; }
        history = history.slice(0, currentIndex + 1);
        history.push({ board: nb, senteMoti: sm, goteMoti: gm, moveText: moveText, turn: 1-d.turn, lastPos: {r:tr, c:tc}, kifMove: moveText.substring(1) });
        currentIndex++; if (!silent) playMoveSound(); render();
    }

    // 共通KIF解析ロジック
    function parseKifContent(content) {
        try {
            history = getCleanHistory(); currentIndex = 0;
            const lines = content.split(/\r?\n/);
            lines.forEach(line => {
                const m = line.match(/^\s*(\d+)\s+([１-９一-九同].+?)(?:\s|\(|$)/); if (!m) return;
                let moveStr = m[2], tr, tc, fr, fc, pCode, isProm = moveStr.includes('成') && !moveStr.includes('不成');
                if (moveStr.startsWith('同')) { tr = history[currentIndex].lastPos.r; tc = history[currentIndex].lastPos.c; }
                else { tc = 9 - ("１２３４５６７８９".indexOf(moveStr[0]) + 1); tr = "一二三四五六七八九".indexOf(moveStr[1]); }
                pCode = kifPieceMap[moveStr.match(/[歩飛角金銀桂香玉王と竜龍馬全圭杏]/)[0]].replace('+', '');
                if (moveStr.includes('打')) executeMove(null, null, tr, tc, pCode, false, true, true);
                else {
                    const fm = line.match(/\((\d)(\d)\)/); if (fm) { fc = 9 - parseInt(fm[1]); fr = parseInt(fm[2]) - 1; }
                    else {
                        const d = history[currentIndex];
                        outer: for(let r=0; r<9; r++) for(let c=0; c<9; c++) {
                            let p = d.board[r][c]; if(p && p.toLowerCase().replace('+','') === pCode && ((d.turn===0 && p===p.toLowerCase()) || (d.turn===1 && p===p.toUpperCase()))) {
                                if(isValidMove(r, c, tr, tc, p, d.board)) { fr=r; fc=c; break outer; }
                            }
                        }
                    }
                    executeMove(fr, fc, tr, tc, pCode, isProm, false, true);
                }
            });
            jumpTo(history.length - 1);
        } catch (err) { 
            console.error(err);
            showToast(i18n[currentLang].msgKifError); 
        }
    }

    function importKIF(e) {
        const f = e.target.files[0]; if (!f) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            parseKifContent(ev.target.result);
        };
        reader.readAsText(f); e.target.value = "";
    }

    // ★修正★ fetchを使わず、JS内の変数(PRELOAD_KIFS)から直接読み込むように変更
    function loadDefaultKifs() {
        let firstLoadedHistory = null;
        let firstLoadedName = null;
        let anyLoaded = false;

        // PRELOAD_KIFS オブジェクトのキーを回して読み込み
        Object.keys(PRELOAD_KIFS).forEach(key => {
            try {
                const text = PRELOAD_KIFS[key];
                
                // 解析実行
                parseKifContent(text);
                
                // localStorage に保存
                const d = JSON.parse(localStorage.getItem(STORAGE_KEY)||'{}');
                d[key] = history;
                localStorage.setItem(STORAGE_KEY, JSON.stringify(d));
                
                anyLoaded = true;

                // 最初に読み込まれたものをメイン表示用に確保
                if (!firstLoadedHistory) {
                    firstLoadedHistory = history;
                    firstLoadedName = key;
                }
            } catch (e) {
                console.error(`Failed to load ${key}`, e);
            }
        });

        // 最初の棋譜を盤面に復元して表示
        if (firstLoadedHistory) {
            history = firstLoadedHistory;
            currentIndex = history.length - 1;
            document.getElementById('kifuName').value = firstLoadedName;
            render();
            if(anyLoaded) showToast("初期棋譜を読み込みました");
        } else {
            // 何も読み込めなかった場合は初期化
            history = getCleanHistory();
            render();
        }
        updateList();
    }

    function exportKIF() {
        let kif = `手合割：平手\n手数----指手----\n`; history.forEach((h, i) => { if(i>0) kif += `${i.toString().padStart(4)} ${h.kifMove}\n`; });
        const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([kif], {type:'text/plain'}));
        a.download = `${document.getElementById('kifuName').value || 'kifu'}.kif`; a.click();
    }

    function exportAllJSON() {
        const d = localStorage.getItem(STORAGE_KEY); if(!d || d === "{}") return showToast(i18n[currentLang].msgNoData);
        const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([d], {type:'application/json'})); a.download = 'shogi_backup.json'; a.click();
    }

    function importAllJSON(e) {
        const f = e.target.files[0]; if(!f) return;
        const r = new FileReader(); r.onload = (ev) => {
            try { if(confirm(i18n[currentLang].msgRestoreConfirm)) { localStorage.setItem(STORAGE_KEY, JSON.stringify({...JSON.parse(localStorage.getItem(STORAGE_KEY)||'{}'), ...JSON.parse(ev.target.result)})); updateList(); showToast(i18n[currentLang].msgDone); } }
            catch { showToast("Error"); }
        };
        r.readAsText(f); e.target.value = "";
    }

    function updateHistoryUI() { 
        const h = document.getElementById('history');
        h.innerHTML = history.map((x,i) => `<div class="history-item ${i===currentIndex?'current-move':''}" onclick="jumpTo(${i})">${i === 0 ? x.moveText : i + '. ' + x.moveText}</div>`).join('');
        const activeItem = h.querySelector('.current-move');
        const isMobile = /iPhone|Android.+Mobile|Windows Phone|webOS|BlackBerry|Opera Mini|IEMobile|Mobile/i.test(navigator.userAgent) || window.innerWidth < 1000;
        if (activeItem && !isMobile) activeItem.scrollIntoView({ block: 'nearest' });
    }
    function jumpTo(i) { currentIndex = i; selected = null; render(); }
    function prevMove() { if(currentIndex > 0) jumpTo(currentIndex-1); }
    function nextMove() { if(currentIndex < history.length-1) jumpTo(currentIndex+1); }
    function saveKifu() {
        const n = document.getElementById('kifuName').value; if(!n) return;
        const d = JSON.parse(localStorage.getItem(STORAGE_KEY)||'{}'); d[n] = history;
        localStorage.setItem(STORAGE_KEY, JSON.stringify(d)); updateList(); showToast(i18n[currentLang].msgSaved);
    }
    function renameKifu() {
        const select = document.getElementById('kifuList'); if (select.selectedOptions.length !== 1) return showToast(i18n[currentLang].msgSelectOne);
        const oldName = select.value, newName = prompt(i18n[currentLang].msgRenamePrompt, oldName);
        if (newName && newName !== oldName) {
            const d = JSON.parse(localStorage.getItem(STORAGE_KEY)||'{}'); d[newName] = d[oldName]; delete d[oldName];
            localStorage.setItem(STORAGE_KEY, JSON.stringify(d)); document.getElementById('kifuName').value = newName; updateList();
        }
    }
    function updateList() {
        const d = JSON.parse(localStorage.getItem(STORAGE_KEY)||'{}');
        document.getElementById('kifuList').innerHTML = Object.keys(d).sort().map(k => `<option value="${k}">${k}</option>`).join('');
    }
    function loadKifu() {
        const select = document.getElementById('kifuList'); if (select.selectedOptions.length > 1) return showToast(i18n[currentLang].msgSelectOne);
        const n = select.value; if(n){ history = JSON.parse(localStorage.getItem(STORAGE_KEY))[n]; currentIndex = history.length - 1; document.getElementById('kifuName').value = n; render(); }
    }
    function deleteKifu() {
        const select = document.getElementById('kifuList'), items = Array.from(select.selectedOptions).map(opt => opt.value);
        if (items.length > 0 && confirm(i18n[currentLang].msgConfirmDel)) {
            const d = JSON.parse(localStorage.getItem(STORAGE_KEY)); items.forEach(name => delete d[name]); localStorage.setItem(STORAGE_KEY, JSON.stringify(d)); updateList();
        }
    }
    
    window.onload = () => { 
        history = getCleanHistory(); 
        updateUIStrings(); 
        render(); 
        updateList(); 
        loadDefaultKifs(); // 埋め込みデータの読み込み実行
    };

    window.copyKIF = function() {
        let kif = `手合割：平手\n手数----指手----\n`; history.forEach((h, i) => { if(i>0) kif += `${i.toString().padStart(4)} ${h.kifMove}\n`; });
        navigator.clipboard.writeText(kif).then(() => showToast(i18n[currentLang].copySuccess), () => showToast(i18n[currentLang].copyFail));
    };
</script>
<br>
棋譜の保存やKIF形式での入出力に完全対応し、自分だけの対局記録や研究案を簡単に管理できる多機能将棋盤アプリです。<br>
定跡の手順を実際に入力して保存できるため、手順の確認や暗記といった日々の研究・トレーニングに最適です。<br>
厳密な反則チェックやスマホでの快適な操作性を備え、本格的な将棋の学習や棋譜の振り返りを強力にサポートします。<br><br>

This versatile Shogi app fully supports KIF format I/O and local saving, allowing you to manage your personal game records and research ideas with ease. Since you can input and save joseki sequences, it is the perfect tool for daily training and move memorization. With strict rule-checking and a mobile-optimized interface, it provides powerful support for serious Shogi study and game review.
</body>
</html>